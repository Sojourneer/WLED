<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>${ef67305f219a928b34a21e0cad5d7d2e2e05c68e:LED Settings}</title>
<script async="" src="common.js" type="text/javascript"></script>
<script>
		var laprev=55,maxB=1,maxD=1,maxA=1,maxV=0,maxM=4000,maxPB=2048,maxL=1664,maxCO=5,maxLbquot=0; //maximum bytes for LED allocation: 4kB for 8266, 32kB for 32
		var oMaxB=1;
		var customStarts=false,startsDirty=[];
		function off(n)    { gN(n).value = -1;}
		// these functions correspond to C macros found in const.h
		function gT(t)     { for (let type of d.ledTypes) if (t == type.i) return type; } // getType from available ledTypes
		function isPWM(t)  { return gT(t).t.charAt(0) === "A"; }    // is PWM type
		function isAna(t)  { return gT(t).t === "" || isPWM(t); }   // is analog type
		function isDig(t)  { return gT(t).t === "D" || isD2P(t); }  // is digital type
		function isD2P(t)  { return gT(t).t === "2P"; }             // is digital 2 pin type
		function isNet(t)  { return gT(t).t === "N"; }              // is network type
		function isVir(t)  { return gT(t).t === "V" || isNet(t); }  // is virtual type
		function hasRGB(t) { return !!(gT(t).c & 0x01); }           // has RGB
		function hasW(t)   { return !!(gT(t).c & 0x02); }           // has white channel
		function hasCCT(t) { return !!(gT(t).c & 0x04); }           // is white CCT enabled
		function is16b(t)  { return !!(gT(t).c & 0x10); }           // is digital 16 bit type
		function mustR(t)  { return !!(gT(t).c & 0x20); }           // Off refresh is mandatory
		function numPins(t){ return Math.max(gT(t).t.length, 1); }  // type length determines number of GPIO pins
		function S() {
			getLoc();
			loadJS(getURL('/settings/s.js?p=2'), false, ()=>{
				d.ledTypes = [/*{i:22,c:1,t:"D",n:"WS2812"},{i:42,c:6,t:"AA",n:"PWM CCT"}*/]; // filled from GetV()
				d.um_p = [];
				d.rsvd = [];
				d.ro_gpio = [];
				d.max_gpio = 50;
			}, ()=>{
				checkSi();
				setABL();
				d.Sf.addEventListener("submit", trySubmit);
				if (d.um_p[0]==-1) d.um_p.shift();
				pinDropdowns();
			});	// If we set async false, file is loaded and executed, then next statement is processed
			if (loc) d.Sf.action = getURL('/settings/leds');
		}
		function bLimits(b,v,p,m,l,o=5,d=2,a=6) {
			// maxB - max buses (can be changed if using ESP32 parallel I2S)
			// maxD - max digital channels (can be changed if using ESP32 parallel I2S)
			// maxA - max analog channels
			// maxV - min virtual buses
			// maxPB - max LEDs per bus
			// maxM - max LED memory
			// maxL - max LEDs (will serve to determine ESP >1664 == ESP32)
			// maxCO - max Color Order mappings
			oMaxB = maxB = b; maxD = d, maxA = a, maxV = v; maxM = m; maxPB = p; maxL = l; maxCO = o;
		}
		function pinsOK() {
			var ok = true;
			var nList = d.Sf.querySelectorAll("#mLC input[name^=L]");
			nList.forEach((LC,i)=>{
				if (!ok) return; // prevent iteration after conflict
				let nm = LC.name.substring(0,2);
				let n = LC.name.substring(2);
				let t = parseInt(d.Sf["LT"+n].value, 10); // LED type SELECT
				// ignore IP address
				if (nm=="L0" || nm=="L1" || nm=="L2" || nm=="L3") {
					if (isNet(t)) return;
				}
				//check for pin conflicts
				if (nm=="L0" || nm=="L1" || nm=="L2" || nm=="L3" || nm=="L4")
					if (LC.value!="" && LC.value!="-1") {
						let p = d.rsvd.concat(d.um_p); // used pin array
						d.Sf.querySelectorAll("select.pin").forEach((e)=>{if(e.value>-1)p.push(parseInt(e.value));}) // buttons, IR & relay
						if (p.some((e)=>e==parseInt(LC.value))) {
							alert(`Sorry, pins ${JSON.stringify(p)} can't be used.`);
							LC.value="";
							LC.focus();
							ok = false;
							return;
						} else if (d.ro_gpio.some((e)=>e==parseInt(LC.value))) {
							alert(`Sorry, pins ${JSON.stringify(d.ro_gpio)} are input only.`);
							LC.value="";
							LC.focus();
							ok = false;
							return;
						}
						for (j=i+1; j<nList.length; j++) {
							let n2 = nList[j].name.substring(0,2);
							if (n2=="L0" || n2=="L1" || n2=="L2" || n2=="L3" || n2=="L4") {
								if (n2.substring(0,1)==="L") {
									var m  = nList[j].name.substring(2);
									var t2 = parseInt(d.Sf["LT"+m].value, 10);
									if (t2>=80) continue;
								}
								if (nList[j].value!="" && nList[i].value==nList[j].value) {
									alert(`Pin conflict between ${LC.name}/${nList[j].name}!`);
									nList[j].value="";
									nList[j].focus();
									ok = false;
									return;
								}
							}
						}
					}
			});
			return ok;
		}
		function trySubmit(e) {
			d.Sf.data.value = '';
			e.preventDefault();
			if (!pinsOK()) {e.stopPropagation();return false;} // Prevent form submission and contact with server
			if (bquot > 100) {var msg = "Too many LEDs for me to handle!"; if (maxM < 10000) msg += "\n\rConsider using an ESP32."; alert(msg);}
			if (!d.Sf.ABL.checked || d.Sf.PPL.checked) d.Sf.MA.value = 0; // submit 0 as ABL (PPL will handle it)
			if (d.Sf.checkValidity()) {
				d.Sf.querySelectorAll("#mLC select[name^=LT]").forEach((s)=>{s.disabled=false;}); // just in case
				d.Sf.submit(); //https://stackoverflow.com/q/37323914
			}
		}
		function enABL()
		{
			var en = d.Sf.ABL.checked;
			gId('abl').style.display = (en) ? 'inline':'none';
			gId('psu2').style.display = (en) ? 'inline':'none';
			if (!en) {
				// limiter disabled
				d.Sf.PPL.checked = false;
//				d.Sf.querySelectorAll("#mLC select[name^=LAsel]").forEach((e)=>{e.selectedIndex = 0;}); // select default LED mA
//				d.Sf.querySelectorAll("#mLC input[name^=LA]").forEach((e)=>{e.min = 0; e.value = 0;}); // set min & value to 0
			}
			UI();
		}
		// enable per port limiter and calculate current
		function enPPL(sDI=0)
		{
			const abl = d.Sf.ABL.checked;
			const ppl = d.Sf.PPL.checked;
			let sumMA = 0;
			d.Sf.MA.readonly = ppl;
			d.Sf.MA.min = abl && !ppl ? 250 : 0;
			gId("psuMA").style.display = ppl ? 'none' : 'inline';
			gId("ppldis").style.display = ppl ? 'inline' : 'none';
			// set PPL minimum value and clear actual PPL limit if ABL is disabled
			d.Sf.querySelectorAll("#mLC input[name^=MA]").forEach((i,x)=>{
				var n = String.fromCharCode((x<10?48:55)+x);
				gId("PSU"+n).style.display = ppl ? "inline" : "none";
				const t = parseInt(d.Sf["LT"+n].value); // LED type SELECT
				const c = parseInt(d.Sf["LC"+n].value); //get LED count
				i.min = ppl && isDig(t) ? 250 : 0;
				if (!abl || !isDig(t)) i.value = 0;
				else if (ppl) sumMA += parseInt(i.value,10);
				else if (sDI) i.value = Math.round(parseInt(d.Sf.MA.value,10)*c/sDI);
			});
			if (ppl) d.Sf.MA.value = sumMA; // populate UI ABL value if PPL used
		}
		// enable and update LED Amps
		function enLA(s,n)
		{
			const abl = d.Sf.ABL.checked;
			const t = parseInt(d.Sf["LT"+n].value); // LED type SELECT
			gId('LAdis'+n).style.display = s.selectedIndex==5 ? "inline" : "none"; // show/hide custom mA field
			if (s.value!=="0") d.Sf["LA"+n].value = s.value; // set value from select object
			d.Sf["LA"+n].min = (!isDig(t) || !abl) ? 0 : 1; // set minimum value for validation
		}
		function setABL()
		{
			let en = parseInt(d.Sf.MA.value) > 0;
			// check if ABL is enabled (max mA entered per output)
			d.Sf.querySelectorAll("#mLC input[name^=MA]").forEach((i,n)=>{
				if (parseInt(i.value) > 0) en = true;
			});
			d.Sf.ABL.checked = en;
			// select appropriate LED current
			d.Sf.querySelectorAll("#mLC select[name^=LAsel]").forEach((sel,x)=>{
				sel.value = 0; // set custom
				var n = String.fromCharCode((x<10?48:55)+x);
				if (en)
					switch (parseInt(d.Sf["LA"+n].value)) {
						case 0: break; // disable ABL
						case 15: sel.value = 15; break;
						case 30: sel.value = 30; break;
						case 35: sel.value = 35; break;
						case 55: sel.value = 55; break;
						case 255: sel.value = 255; break;
					}
				else sel.value = 0;
				enLA(sel,n); // configure individual limiter
			});
			enABL();
			gId('m1').innerHTML = maxM;
		}
		//returns mem usage
		function getMem(t, n) {
			if (isAna(t)) return 5;	// analog
			let len = parseInt(d.getElementsByName("LC"+n)[0].value);
			len += parseInt(d.getElementsByName("SL"+n)[0].value); // skipped LEDs are allocated too
			let dbl = 0;
			let ch = 3*hasRGB(t) + hasW(t) + hasCCT(t);
			let mul = 1;
			if (isDig(t)) {
				if (is16b(t)) len *= 2; // 16 bit LEDs
				if (maxM < 10000 && d.getElementsByName("L0"+n)[0].value == 3) { //8266 DMA uses 5x the mem
					mul = 5;
				}
				if (maxM >= 10000) { //ESP32 RMT uses double buffer?
					mul = 2;
				}
				if (d.Sf.LD.checked) dbl = len * ch; // double buffering
			}
			return len * ch * mul + dbl;
		}

		function UI(change=false)
		{
			let gRGBW = false, memu = 0;
			let busMA = 0;
			let sLC = 0, sPC = 0, sDI = 0, maxLC = 0;
			const abl = d.Sf.ABL.checked;
			maxB = oMaxB; // TODO make sure we start with all possible buses
			let setPinConfig = (n,t) => {
				let p0d = "GPIO:";
				let p1d = "";
				let off = "Off Refresh";
				switch (gT(t).t.charAt(0)) {
					case '2': // 2 pin digital
						p1d = "Clock "+p0d;
						// fallthrough
					case 'D': // digital
						p0d = "Data "+p0d;
						break;
					case 'A': // PWM analog
						if (numPins(t) > 1) p0d = "GPIOs:";
						off = "Dithering";
						break;
					case 'N': // network
						p0d = "IP address:";
						break;
					case 'V': // virtual/non-GPIO based
						p0d = "Config:"
						break;
				}
				gId("p0d"+n).innerText = p0d;
				gId("p1d"+n).innerText = p1d;
				gId("off"+n).innerText = off;
				// secondary pins show/hide (type string length is equivalent to number of pins used; except for network and on/off)
				let pins = Math.max(gT(t).t.length,1) + 3*isNet(t); // fixes network pins to 4
				for (let p=1; p<5; p++) {
					var LK = d.Sf["L"+p+n];
					if (!LK) continue;
					LK.style.display = (p < pins) ? "inline" : "none";
					LK.required = (p < pins);
					if (p >= pins) LK.value="";
				}
			}

			// enable/disable LED fields
			let LTs = d.Sf.querySelectorAll("#mLC select[name^=LT]");
			LTs.forEach((s,i)=>{
				if (i < LTs.length-1) s.disabled = true; // prevent changing type (as we can't update options)
				// is the field a LED type?
				var n = s.name.substring(2);
				var t = parseInt(s.value);
				memu += getMem(t, n); // calc memory
				setPinConfig(n,t);
				gId("abl"+n).style.display = (!abl || !isDig(t)) ? "none" : "inline"; // show/hide individual ABL settings
				if (change) { // did we change LED type?
					gId("rf"+n).checked = (gId("rf"+n).checked || t == 31); // LEDs require data in off state (mandatory for TM1814)
					if (isAna(t)) d.Sf["LC"+n].value = 1;                   // for sanity change analog count just to 1 LED
					d.Sf["LA"+n].min = (!isDig(t) || !abl) ? 0 : 1;         // set minimum value for LED mA
					d.Sf["MA"+n].min = (!isDig(t)) ? 0 : 250;               // set minimum value for PSU mA
				}
				gId("rf"+n).onclick = mustR(t) ? (()=>{return false}) : (()=>{});           // prevent change change of "Refresh" checkmark when mandatory
				gRGBW |= hasW(t);                                                           // RGBW checkbox
				gId("co"+n).style.display = (isVir(t) || isAna(t)) ? "none":"inline";       // hide color order for PWM
				gId("dig"+n+"w").style.display = (isDig(t) && hasW(t)) ? "inline":"none";   // show swap channels dropdown
				gId("dig"+n+"w").querySelector("[data-opt=CCT]").disabled = !hasCCT(t);     // disable WW/CW swapping	
				if (!(isDig(t) && hasW(t))) d.Sf["WO"+n].value = 0;                         // reset swapping
				gId("dig"+n+"c").style.display = (isAna(t)) ? "none":"inline";              // hide count for analog
				gId("dig"+n+"r").style.display = (isVir(t)) ? "none":"inline";              // hide reversed for virtual
				gId("dig"+n+"s").style.display = (isVir(t) || isAna(t)) ? "none":"inline";  // hide skip 1st for virtual & analog
				gId("dig"+n+"f").style.display = (isDig(t) || (isPWM(t) && maxL>2048)) ? "inline":"none"; // hide refresh (PWM hijacks reffresh for dithering on ESP32)
				gId("dig"+n+"a").style.display = (hasW(t)) ? "inline":"none";               // auto calculate white
				gId("dig"+n+"l").style.display = (isD2P(t) || isPWM(t)) ? "inline":"none";  // bus clock speed / PWM speed (relative) (not On/Off)
				gId("rev"+n).innerHTML = isAna(t) ? "Inverted output":"Reversed";           // change reverse text for analog else (rotated 180°)
				//gId("psd"+n).innerHTML = isAna(t) ? "Index:":"Start:";                      // change analog start description
			});
			// display global white channel overrides
			gId("wc").style.display = (gRGBW) ? 'inline':'none';
			if (!gRGBW) {
				d.Sf.AW.selectedIndex = 0;
				d.Sf.CR.checked = false;
			}
			// update start indexes, max values, calculate current, etc
			var nList = d.Sf.querySelectorAll("#mLC input[name^=L]");
			nList.forEach((LC,i)=>{
				let nm = LC.name.substring(0,2);  // field name
				let n  = LC.name.substring(2);    // bus number
				let t  = parseInt(d.Sf["LT"+n].value); // LED type SELECT
				// do we have a led count field
				if (nm=="LC") {
					let c = parseInt(LC.value,10); //get LED count
					if (c > 300 && i < 8) maxB = oMaxB - Math.max(maxD-7,0); //TODO: hard limit for buses when using ESP32 parallel I2S
					if (!customStarts || !startsDirty[n]) gId("ls"+n).value=sLC; //update start value
					gId("ls"+n).disabled = !customStarts; //enable/disable field editing
					if (c) {
						let s = parseInt(gId("ls"+n).value); //start value
						if (s+c > sLC) sLC = s+c; //update total count
						if (c > maxLC) maxLC = c; //max per output
						if (!isVir(t)) sPC += c; //virtual out busses do not count towards physical LEDs
						if (isDig(t)) {
							sDI += c; // summarize digital LED count
							let maPL = parseInt(d.Sf["LA"+n].value);
							if (maPL == 255) maPL = 12;
							busMA += maPL*c; // summarize maximum bus current (calculated)
						}
					} // increase led count
					return;
				}
				// do we have led pins for digital leds
				if (nm=="L0" || nm=="L1") {
					d.Sf["LC"+n].max = maxPB; // update max led count value
				}
				// ignore IP address (stored in pins for virtual busses)
				if (nm=="L0" || nm=="L1" || nm=="L2" || nm=="L3") {
					if (isVir(t)) {
						LC.max = 255;
						LC.min = 0;
						LC.style.color="#fff";
						return; // do not check conflicts
					} else {
						LC.max = d.max_gpio;
						LC.min = -1;
					}
				}
				// check for pin conflicts & color fields
				if (nm=="L0" || nm=="L1" || nm=="L2" || nm=="L3" || nm=="L4")
					if (LC.value!="" && LC.value!="-1") {
						let p = d.rsvd.concat(d.um_p); // used pin array
						d.Sf.querySelectorAll("select.pin").forEach((e)=>{if(e.value>-1)p.push(parseInt(e.value));}) // buttons, IR & relay
						for (j=0; j<nList.length; j++) {
							if (i==j) continue;
							let n2 = nList[j].name.substring(0,2);
							if (n2=="L0" || n2=="L1" || n2=="L2" || n2=="L3" || n2=="L4") {
								if (n2.substring(0,1)==="L") {
									let m  = nList[j].name.substring(2);
									let t2 = parseInt(d.Sf["LT"+m].value, 10);
									if (isVir(t2)) continue;
								}
								if (nList[j].value!="" && nList[j].value!="-1") p.push(parseInt(nList[j].value,10));  // add current pin
							}
						}
						// now check for conflicts
						if (p.some((e)=>e==parseInt(LC.value))) LC.style.color = "red";
						else LC.style.color = d.ro_gpio.some((e)=>e==parseInt(LC.value)) ? "orange" : "#fff";
					}
			});
			// distribute ABL current if not using PPL
			enPPL(sDI);

			// update total led count
			gId("lc").textContent = sLC;
			gId("pc").textContent = (sLC == sPC) ? "":"(" + sPC + " physical)";

			// memory usage and warnings
			gId('m0').innerHTML = memu;
			bquot = memu / maxM * 100;
			gId('dbar').style.background = `linear-gradient(90deg, ${bquot > 60 ? (bquot > 90 ? "red":"orange"):"#ccc"} 0 ${bquot}%, #444 ${bquot}% 100%)`;
			gId('ledwarning').style.display = (maxLC > Math.min(maxPB,800) || bquot > 80) ? 'inline':'none';
			gId('ledwarning').style.color = (maxLC > Math.max(maxPB,800) || bquot > 100) ? 'red':'orange';
			gId('wreason').innerHTML = (bquot > 80) ? "80% of max. LED memory" +(bquot>100 ? ` (<b>ERROR: Using over ${maxM}B!</b>)` : "") : "800 LEDs per output";
			// calculate power
			gId('ampwarning').style.display = (parseInt(d.Sf.MA.value,10) > 7200) ? 'inline':'none';
			var val = Math.ceil((100 + busMA)/500)/2;
			val = (val > 5) ? Math.ceil(val) : val;
			var s = "A power supply with total of ";
			s += val;
			s += "A is required.";
			var val2 = Math.ceil((100 + busMA)/1500)/2;
			val2 = (val2 > 5) ? Math.ceil(val2) : val2;
			var s2 = "(for most effects, ~";
			s2 += val2;
			s2 += "A is enough)<br>";
			gId('psu').innerHTML = s;
			gId('psu2').innerHTML = s2;
			gId("json").style.display = d.Sf.IT.value==8 ? "" : "none";
		}
		function lastEnd(i) {
			if (i-- < 1) return 0;
			var s = String.fromCharCode((i<10?48:55)+i);
			v = parseInt(d.getElementsByName("LS"+s)[0].value) + parseInt(d.getElementsByName("LC"+s)[0].value);
			var t = parseInt(d.getElementsByName("LT"+s)[0].value);
			if (isPWM(t)) v = 1; //PWM busses
			return isNaN(v) ? 0 : v;
		}
		function addLEDs(n,init=true)
		{
			var o = gEBCN("iST");
			var i = o.length;
			let disable = (sel,opt) => { sel.querySelectorAll(opt).forEach((o)=>{o.disabled=true;}); }

			var f = gId("mLC");
			let digitalB = 0, analogB = 0, twopinB = 0, virtB = 0;
			f.querySelectorAll("select[name^=LT]").forEach((s)=>{
				let t = s.value;
				if (isDig(t) && !isD2P(t)) digitalB++;
				if (isD2P(t)) twopinB++;
				if (isPWM(t)) analogB += numPins(t); // each GPIO is assigned to a channel
				if (isVir(t)) virtB++;
			});

			if ((n==1 && i>=maxB+maxV) || (n==-1 && i==0)) return;
			var s = String.fromCharCode((i<10?48:55)+i);

			if (n==1) {
// npm run build has trouble minimizing spaces inside string
				var cn = `<div class="iST">
<hr class="sml">
${i+1}:
<select name="LT${s}" onchange="UI(true)"></select><br>
<div id="abl${s}">
mA/LED: <select name="LAsel${s}" onchange="enLA(this,'${s}');UI();">
<option value="55" selected>55mA (typ. 5V WS281x)</option>
<option value="35">35mA (eco WS2812)</option>
<option value="30">30mA (typ. 12V)</option>
<option value="255">12mA (WS2815)</option>
<option value="15">15mA (seed/fairy pixels)</option>
<option value="0">Custom</option>
</select><br>
<div id="LAdis${s}" style="display: none;">max. mA/LED: <input name="LA${s}" type="number" min="1" max="255" oninput="UI()"> mA<br></div>
<div id="PSU${s}">PSU: <input name="MA${s}" type="number" class="xl" min="250" max="65000" oninput="UI()" value="250"> mA<br></div>
</div>
<div id="co${s}" style="display:inline">Color Order:
<select name="CO${s}">
<option value="0">GRB</option>
<option value="1">RGB</option>
<option value="2">BRG</option>
<option value="3">RBG</option>
<option value="4">BGR</option>
<option value="5">GBR</option>
</select></div>
<div id="dig${s}w" style="display:none">Swap: <select name="WO${s}"><option value="0">None</option><option value="1">W & B</option><option value="2">W & G</option><option value="3">W & R</option><option data-opt="CCT" value="4">WW & CW</option></select></div>
<div id="dig${s}l" style="display:none">Clock: <select name="SP${s}"><option value="0">Slowest</option><option value="1">Slow</option><option value="2">Normal</option><option value="3">Fast</option><option value="4">Fastest</option></select></div>
<div>
<span id="psd${s}">Start:</span> <input type="number" name="LS${s}" id="ls${s}" class="l starts" min="0" max="8191" value="${lastEnd(i)}" oninput="startsDirty[${i}]=true;UI();" required />&nbsp;
<div id="dig${s}c" style="display:inline">Length: <input type="number" name="LC${s}" class="l" min="1" max="${maxPB}" value="1" required oninput="UI()" /></div><br>
</div>
<span id="p0d${s}">GPIO:</span><input type="number" name="L0${s}" required class="s" onchange="UI();pinUpd(this);"/>
<span id="p1d${s}"></span><input type="number" name="L1${s}" class="s" onchange="UI();pinUpd(this);"/>
<span id="p2d${s}"></span><input type="number" name="L2${s}" class="s" onchange="UI();pinUpd(this);"/>
<span id="p3d${s}"></span><input type="number" name="L3${s}" class="s" onchange="UI();pinUpd(this);"/>
<span id="p4d${s}"></span><input type="number" name="L4${s}" class="s" onchange="UI();pinUpd(this);"/>
<div id="dig${s}r" style="display:inline"><br><span id="rev${s}">Reversed</span>: <input type="checkbox" name="CV${s}"></div>
<div id="dig${s}s" style="display:inline"><br>Skip first LEDs: <input type="number" name="SL${s}" min="0" max="255" value="0" oninput="UI()"></div>
<div id="dig${s}f" style="display:inline"><br><span id="off${s}">Off Refresh</span>: <input id="rf${s}" type="checkbox" name="RF${s}"></div>
<div id="dig${s}a" style="display:inline"><br>Auto-calculate W channel from RGB:<br><select name="AW${s}"><option value=0>None</option><option value=1>Brighter</option><option value=2>Accurate</option><option value=3>Dual</option><option value=4>Max</option></select>&nbsp;</div>
</div>`;
				f.insertAdjacentHTML("beforeend", cn);
				// fill led types (credit @netmindz)
				f.querySelectorAll("select[name^=LT]").forEach((sel,n)=>{
					if (sel.length == 0) { // ignore already updated
						for (let type of d.ledTypes) {
							let opt = cE("option");
							opt.value = type.i;
							opt.text = type.n;
							if (type.t != undefined && type.t != "") {
								opt.setAttribute('data-type', type.t);
							}
							sel.appendChild(opt);			
						}
					}
				});
				// disable inappropriate LED types
				let sel = d.getElementsByName("LT"+s)[0]
				if (i >= maxB || digitalB >= maxD) disable(sel,'option[data-type="D"]'); // NOTE: see isDig()
				if (i >= maxB || twopinB >= 1)     disable(sel,'option[data-type="2P"]'); // NOTE: see isD2P()
				disable(sel,`option[data-type^="${'A'.repeat(maxA-analogB+1)}"]`); // NOTE: see isPWM()
				sel.selectedIndex = sel.querySelector('option:not(:disabled)').index;
			}
			if (n==-1) {
				o[--i].remove();--i;
				o[i].querySelector("[name^=LT]").disabled = false;
			}

			gId("+").style.display = (i<maxB+maxV-1) ? "inline":"none";
			gId("-").style.display = (i>0) ? "inline":"none";

			if (!init) {
				UI();
			}
		}

		function addCOM(start=0,len=1,co=0) {
			var i = gEBCN("com_entry").length;
			if (i >= maxCO) return;
			var s = String.fromCharCode((i<10?48:55)+i);
			var b = `<div class="com_entry">
<hr class="sml">
${i+1}: Start: <input type="number" name="XS${s}" id="xs${s}" class="l starts" min="0" max="65535" value="${start}" oninput="UI();" required="">&nbsp;
Length: <input type="number" name="XC${s}" id="xc${s}" class="l" min="1" max="65535" value="${len}" required="" oninput="UI()">
<div>Color Order:
<select id="xo${s}" name="XO${s}">
<option value="0">GRB</option>
<option value="1">RGB</option>
<option value="2">BRG</option>
<option value="3">RBG</option>
<option value="4">BGR</option>
<option value="5">GBR</option>
</select>
Swap: <select id="xw${s}" name="XW${s}">
<option value="0">Use global</option>
<option value="1">W & B</option>
<option value="2">W & G</option>
<option value="3">W & R</option>
</select>
</div></div>`;
			gId("com_entries").insertAdjacentHTML("beforeend", b);
			gId("xo"+s).value = co & 0x0F;
			gId("xw"+s).value = co >> 4;
			btnCOM(i+1);
			UI();
		}

		function remCOM() {
			var entries = gEBCN("com_entry");
			var i = entries.length;
			if (i === 0) return;
			entries[i-1].remove();
			btnCOM(i-1);
			UI();
		}

		function resetCOM(_newMaxCOOverrides=undefined) {
			if (_newMaxCOOverrides) {
				maxCO = _newMaxCOOverrides;
			}
			for (let e of gEBCN("com_entry")) {
				e.remove();
			}
			btnCOM(0);
		}

		function btnCOM(i) {
			gId("com_add").style.display = (i<maxCO) ? "inline":"none";
			gId("com_rem").style.display = (i>0) ? "inline":"none";
		}

		function addBtn(i,p,t) {
			var c = gId("btns").innerHTML;
			var s = String.fromCharCode((i<10?48:55)+i);
			c += `Button ${i} GPIO: <input type="number" name="BT${s}" onchange="UI()" class="xs" value="${p}">`;
			c += `&nbsp;<select name="BE${s}">`
			c += `<option value="0" ${t==0?"selected":""}>Disabled</option>`;
			c += `<option value="2" ${t==2?"selected":""}>Pushbutton</option>`;
			c += `<option value="3" ${t==3?"selected":""}>Push inverted</option>`;
			c += `<option value="4" ${t==4?"selected":""}>Switch</option>`;
			c += `<option value="5" ${t==5?"selected":""}>PIR sensor</option>`;
			c += `<option value="6" ${t==6?"selected":""}>Touch</option>`;
			c += `<option value="7" ${t==7?"selected":""}>Analog</option>`;
			c += `<option value="8" ${t==8?"selected":""}>Analog inverted</option>`;
			c += `<option value="9" ${t==9?"selected":""}>Touch (switch)</option>`;
			c += `</select>`;
			c += `<span style="cursor: pointer;" onclick="off('BT${s}')">&nbsp;&#x2715;</span><br>`;
			gId("btns").innerHTML = c;
		}
		function tglSi(cs) {
			customStarts = cs;
			if (!customStarts) startsDirty = []; //set all starts to clean
			UI();
		}
		function checkSi() { //on load, checks whether there are custom start fields
			var cs = false;
			for (var i=1; i < gEBCN("iST").length; i++) {
				var v = parseInt(gId("ls"+(i-1)).value) + parseInt(gN("LC"+(i-1)).value);
				if (v != parseInt(gId("ls"+i).value)) {cs = true; startsDirty[i] = true;}
			}
			if (gId("ls0") && parseInt(gId("ls0").value) != 0) {cs = true; startsDirty[0] = true;}
			gId("si").checked = cs;
			tglSi(cs);
		}
		// https://stackoverflow.com/questions/7346563/loading-local-json-file
		function loadCfg(o) {
			var f, fr;

			if (typeof window.FileReader !== 'function') {
				alert("The file API isn't supported on this browser yet.");
				return;
			}

			if (!o.files) {
				alert("This browser doesn't support the `files` property of file inputs.");
			} else if (!o.files[0]) {
				alert("Please select a JSON file first!");
			} else {
				f = o.files[0];
				fr = new FileReader();
				fr.onload = receivedText;
				fr.readAsText(f);
			}
			o.value = '';

			function receivedText(e) {
				let lines = e.target.result;
				var c = JSON.parse(lines); 
				if (c.hw) {
					if (c.hw.led) {
						for (var i=0; i<10; i++) addLEDs(-1);
						var l = c.hw.led;
						l.ins.forEach((v,i,a)=>{
							addLEDs(1);
							for (var j=0; j<v.pin.length; j++) d.getElementsByName(`L${j}${i}`)[0].value = v.pin[j];
							d.getElementsByName("LT"+i)[0].value = v.type;
							d.getElementsByName("LS"+i)[0].value = v.start;
							d.getElementsByName("LC"+i)[0].value = v.len;
							d.getElementsByName("CO"+i)[0].value = v.order;
							d.getElementsByName("SL"+i)[0].value = v.skip;
							d.getElementsByName("RF"+i)[0].checked = v.ref;
							d.getElementsByName("CV"+i)[0].checked = v.rev;
						});
					}
					if(c.hw.com) {
						resetCOM();
						c.hw.com.forEach(e => {
							addCOM(e.start, e.len, e.order);
						});
					}
					if (c.hw.btn) {
						var b = c.hw.btn;
						if (Array.isArray(b.ins)) gId("btns").innerHTML = "";
						b.ins.forEach((v,i,a)=>{
							addBtn(i,v.pin[0],v.type);
						});
						d.getElementsByName("TT")[0].value = b.tt;
					}
					if (c.hw.ir) {
						d.getElementsByName("IR")[0].value = c.hw.ir.pin;
						d.getElementsByName("IT")[0].value = c.hw.ir.type;
					}
					if (c.hw.relay) {
						d.getElementsByName("RL")[0].value = c.hw.relay.pin;
						d.getElementsByName("RM")[0].checked = c.hw.relay.rev;
						d.getElementsByName("RO")[0].checked = c.hw.relay.odrain;
					}
					UI();
				}
			}
		}
		function pinDropdowns() {
			let fields = ["IR","RL"]; // IR & relay
			gId("btns").querySelectorAll('input[type="number"]').forEach((e)=>{fields.push(e.name);}) // buttons
			for (let i of d.Sf.elements) {
				if (i.type === "number" && fields.includes(i.name)) { //select all pin select elements
					let v = parseInt(i.value);
					let sel = addDropdown(i.name,0);
					for (var j = -1; j < d.max_gpio; j++) {
						if (d.rsvd.includes(j)) continue;
						let foundPin = d.um_p.indexOf(j);
						let txt = (j === -1) ? "unused" : `${j}`;
						if (foundPin >= 0 && j !== v) txt += ` used`; // already reserved pin
						if (d.ro_gpio.includes(j)) txt += " (R/O)";
						let opt = addOption(sel, txt, j);
						if (j === v) opt.selected = true; // this is "our" pin
						else if (d.um_p.includes(j)) opt.disabled = true; // someone else's pin
					}
				}
			}
			// update select options
			d.Sf.querySelectorAll("select.pin").forEach((e)=>{pinUpd(e);});
			// add dataset values for LED GPIO pins
			d.Sf.querySelectorAll(".iST input.s[name^=L]").forEach((i)=>{
				if (i.value!=="" && i.value>=0)
					i.dataset.val = i.value;
			});
		}
		function pinUpd(e) {
			// update changed select options across all usermods
			let oldV = parseInt(e.dataset.val);
			e.dataset.val = e.value;
			let txt = e.name;
			let pins = [];
			d.Sf.querySelectorAll(".iST input.s[name^=L]").forEach((i)=>{
				if (i.value!=="" && i.value>=0 && i.max<255)
					pins.push(i.value);
			});
			let selects = d.Sf.querySelectorAll("select.pin");
			for (let sel of selects) {
				if (sel == e) continue
				Array.from(sel.options).forEach((i)=>{
					let led = pins.includes(i.value);
					if (!(i.value==oldV || i.value==e.value || led)) return;
					if (i.value == -1) {
						i.text = "unused";
						return
					}
					i.text = i.value;
					if (i.value==oldV) {
						i.disabled = false;
					}
					if (i.value==e.value || led) {
						i.disabled = true;
						i.text += ` ${led?'LED':txt}`;
					}
					if (d.ro_gpio.includes(parseInt(i.value))) i.text += " (R/O)";
				});
			}
		}
		// https://stackoverflow.com/questions/39729741/javascript-change-input-text-to-select-option
		function addDropdown(field) {
			let sel = cE('select');
			sel.classList.add("pin");
			let inp = d.getElementsByName(field)[0];
			if (inp && inp.tagName === "INPUT" && (inp.type === "text" || inp.type === "number")) {  // may also use nodeName
				let v = inp.value;
				let n = inp.name;
				// copy the existing input element's attributes to the new select element
				for (var i = 0; i < inp.attributes.length; ++ i) {
					var att = inp.attributes[i];
					// type and value don't apply, so skip them
					// ** you might also want to skip style, or others -- modify as needed **
					if (att.name != 'type' && att.name != 'value' && att.name != 'class' && att.name != 'style') {
						sel.setAttribute(att.name, att.value);
					}
				}
				sel.setAttribute("data-val", v);
				sel.setAttribute("onchange", "pinUpd(this)");
				// finally, replace the old input element with the new select element
				inp.parentElement.replaceChild(sel, inp);
				return sel;
			}
			return null;
		}
		function addOption(sel,txt,val) {
			if (sel===null) return; // select object missing
			let opt = cE("option");
			opt.value = val;
			opt.text = txt;
			sel.appendChild(opt);
			for (let i=0; i<sel.childNodes.length; i++) {
				let c = sel.childNodes[i];
				if (c.value == sel.dataset.val) sel.selectedIndex = i;
			}
			return opt;
		}
	</script>
<style>@import url("style.css");</style>
<script src="../scripts/localize.js"></script></head>
<body onload="S()">
<form id="form_s" method="post" name="Sf">
<div class="toprow">
<div class="helpB"><button onclick="H('features/settings/#led-settings')" type="button">?</button></div>
<button onclick="B()" type="button">${b52b36b7269fbfc58ec24bb724691951a3decbe8:Back}</button><button type="submit">${efc007a393f66cdb14d57d385822a3d9e36ef873:Save}</button><hr/>
</div>
<h2>${94ef4b2e00939f32280b623e3d4a0228c2ea2957:LED &amp; Hardware setup}</h2><span>${4231e50377cc6c4a63c84ce20db6efaa27c9b9ec:
		Total LEDs: }</span><span id="lc">?</span> <span id="pc"></span><br/>
<i>${df6f1c4955172bca3d341bf1ab0a2efbc5b73bd7:Recommended power supply for brightest white:}</i><br/>
<b><span id="psu">?</span></b><br/>
<span id="psu2"><br/></span>
<br/><span>${1f6c188166f989d0a83f824b29cb609ff0ef2655:
		Enable automatic brightness limiter: }</span><input name="ABL" onchange="enABL()" type="checkbox"/><br/>
<div id="abl">
<i><span>${a9fc61a7b95669ff93c93b3e937296ddcdd00050:Automatically limits brightness to stay close to the limit.}</span><br/><span>${85b0106eaa2f114732b354141714fcce115033b3:
				Keep at &lt;1A if poweing LEDs directly from the ESP 5V pin!}</span><br/><span>${545712d9bba96abc170ffe93449410a9587c3d1e:
				If using multiple outputs it is recommended to use per-output limiter.}</span><br/><span>${3ff6d577a3dbf68bb7a695f124b57d351e53f937:
				Analog (PWM) and virtual LEDs cannot use automatic brightness limiter.}</span><br/></i>
<div id="psuMA"><span>${f111595b2aa0ffc8b86154bf0ced7a9aba3f4ff4:Maximum PSU Current: }</span><input class="xl" max="65000" min="250" name="MA" oninput="UI()" required="" type="number"/><span>${0534704493a32f7e8a7ae32813acae5ac5b8b076: mA}</span><br/></div><span>${a4bd307b849f3bc234e954c1892c632ab1f99730:
			Use per-output limiter: }</span><input name="PPL" onchange="UI()" type="checkbox"/><br/>
<div id="ppldis" style="display:none;">
<i><span>${88efe069511bc74aea50acc125b6646d8b3091f0:Make sure you enter correct value for each LED output.}</span><br/><span>${c82a8dbf2807c35c4c422e8d9f6859bcb24e14dd:
				If using multiple outputs with only one PSU, distribute its power proportionally amongst outputs.}</span></i><br/>
</div>
<div class="warn" id="ampwarning" style="display: none;"><span>${1a9e7cd4466ef59c322cec9ec10ea38ffa5921e4:
				⚠ Your power supply provides high current.}</span><br/><span>${04a42b2f5ced176b1f349b5d825a9f853fa2a1b8:
				To improve the safety of your setup,}</span><br/><span>${b5f9085c21c1335104bee789a1db818bab023ab5:
				please use thick cables,}</span><br/><span>${9bb1082c606a30d1168b0b6a7d876f62cb623037:
				multiple power injection points and a fuse!}</span><br/>
</div>
</div>
<h3>${c185c18be2e1d6a7df737f142be54e6d7c1b0fb9:Hardware setup}</h3>
<div id="mLC">${00247040dbdfb4be9128f6fb74c29351a8bcb474:LED outputs:}</div>
<hr class="sml"/>
<button id="+" onclick="addLEDs(1,false)" type="button">+</button>
<button id="-" onclick="addLEDs(-1,false)" type="button">-</button><br/><span>${c83f81cf7bc95ff4002b829e9b16cb8bf841ebc3:
		LED memory usage: }</span><span id="m0">0</span> / <span id="m1">?</span><span>${cf8ce7db2b900ab8c5bc00003ce24c721f427c1a: B}</span><br/>
<div id="dbar" style="display:inline-block; width: 100px; height: 10px; border-radius: 20px;"></div><br/>
<div class="warn" id="ledwarning" style="display: none;"><span>${aa5244a1331f1c0783095c25cb38956a57c3a56e:
			⚠ You might run into stability or lag issues.}</span><br/><span>${f3935516094203136b1db12471ae78619e9a07ce:
			Use less than }</span><span id="wreason">${3e29452bf89cfecfe9d76998eadc5ba6c85ac33b:800 LEDs per output}</span><span>${446c09ad30cd808865a6f1bcab0daeb85c0a1ca0: for the best experience!}</span><br/>
</div>
<hr class="sml"/><span>${d624cee0db4f4716f4837d8e2b5a516578711c70:
		Make a segment for each output: }</span><input name="MS" type="checkbox"/><br/><span>${5242aff4fcdbc60bd2118662107ec1704503d49e:
		Custom bus start indices: }</span><input id="si" onchange="tglSi(this.checked)" type="checkbox"/><br/><span>${38bd8ac3fc8d9a2df36d6d919725ae4702173cfe:
		Use global LED buffer: }</span><input name="LD" onchange="UI()" type="checkbox"/><br/>
<hr class="sml"/>
<div id="color_order_mapping"><span>${b5c3914317e29693a39b7505ad64d5a9cdad8232:
			Color Order Override:
			}</span><div id="com_entries"></div>
<hr class="sml"/>
<button id="com_add" onclick="addCOM()" type="button">+</button>
<button id="com_rem" onclick="remCOM()" type="button">-</button><br/>
</div>
<hr class="sml"/>
<div id="btns"></div><span>${61444215dce6f711c38cac11fab38ece760114e7:
		Disable internal pull-up/down: }</span><input name="IP" type="checkbox"/><br/><span>${0a383f76ae5d31ac6240160c6facf0e9faa5609d:
		Touch threshold: }</span><input class="s" max="100" min="0" name="TT" required="" type="number"/><br/>
<hr class="sml"/><span>${f9cb7f3c6dd9ed292f4906adadc22f281daa081a:
		IR GPIO: }</span><input class="xs" max="48" min="-1" name="IR" onchange="UI()" type="number"/><select name="IT" onchange="UI()">
<option value="0">${8f3eda69d33dfb8db0e3178c719a8d882575a4ac:Remote disabled}</option>
<option value="1">${3be1533f15a6df19c981ef89d78d449017c93655:24-key RGB}</option>
<option value="2">${5b8f9087270c5b961bcacddc8a2d8d537dc1a31c:24-key with CT}</option>
<option value="3">${a5c5ffdad95705054e8248cb129f47fb3521cc46:40-key blue}</option>
<option value="4">${d9683792f52eca5054885a65330e3934824b1c53:44-key RGB}</option>
<option value="5">${ab21a688734a7cb22980c72143dd1ff1be20873b:21-key RGB}</option>
<option value="6">${9a44851d02c35f682f9f59c67c8354863fb7d298:6-key black}</option>
<option value="7">${27050cf220d839f6d512e0c170534c55ba6a1e27:9-key red}</option>
<option value="8">${3e737c6a547c849cc4bb3acf289a9d752f5b4a59:JSON remote}</option>
</select><span onclick="off('IR')" style="cursor: pointer;"> ✕</span><br/><span>${697c8abc94c694d31a87964eea05fe255c1d6ea0:
		Apply IR change to main segment only: }</span><input name="MSO" type="checkbox"/><br/>
<div id="json" style="display:none;"><span>${db4c4e7e796c96b9701bf3bf964665e04e579af4:JSON file: }</span><input accept=".json" name="data" type="file"/><button class="sml" onclick="uploadFile(d.Sf.data,'/ir.json')" type="button">${8bdf057f91e76ae328b2a21d35f682daa08a0ec0:Upload}</button><br/></div>
<a href="https://kno.wled.ge/interfaces/infrared/" target="_blank">${2c0c6ccda9f9f10296d837620289cf686581cc27:IR info}</a><br/>
<hr class="sml"/><span>${0fb7885a34f402c893e013d55b95ea63ad301e1e:
		Relay GPIO: }</span><input class="xs" max="48" min="-1" name="RL" onchange="UI()" type="number"/><span onclick="off('RL')" style="cursor: pointer;"> ✕</span><br/><span>${52e181a63cb2aa139d4c6bb9992cde224bf3e64a:
		Invert }</span><input name="RM" type="checkbox"/><span>${d2b7653ee5a8c6db90a12dad3d58544d6318c2f4: Open drain }</span><input name="RO" type="checkbox"/><br/>
<hr class="sml"/>
<h3>${428819bf9e83cebda50efafb08cd2534c1583949:Defaults}</h3><span>${2bf4a6ae6f26919a091860b389fb0281291c9cd2:
		Turn LEDs on after power up/reset: }</span><input name="BO" type="checkbox"/><br/><span>${199de5337d9f195832412f9cfbc6e55fd4d8cf08:
		Default brightness: }</span><input class="m" max="255" min="1" name="CA" required="" type="number"/><span>${dfc0d1b0e2224ab589f7294f60f30776da7bcf24: (1-255)}</span><br/><br/><span>${e9d7cc5f7b4be0559011dfc4ae84736277db9d16:
		Apply preset }</span><input class="m" max="250" min="0" name="BP" required="" type="number"/><span>${e8ac640c93dcfeb1dd5c72d8a331f9813b20c924: at boot (0 uses values from above)}</span><br/><br/><span>${87dcc0668c6a7b39a3d46e17412c716a3dece4f3:
		Use Gamma correction for color: }</span><input name="GC" type="checkbox"/><span>${cab4369ce75abc497c318cb8bf95b8043e2e28b5: (strongly recommended)}</span><br/><span>${a0c7cc38fcca5315253d297d3cd00069b00a47cd:
		Use Gamma correction for brightness: }</span><input name="GB" type="checkbox"/><span>${a07ce14f8de6ca5a0850ce9eb418dd1a4e1446ea: (not recommended)}</span><br/><span>${a2598cfb580ac404e429298c373fa5ede6e1d4ae:
		Use Gamma value: }</span><input class="m" data-I18N="placeholder" max="3" min="1" name="GV" placeholder="${368ca55f0f4c6b77876e8bfadc9f650f1c6d984f:2.8}" required="" step="0.1" type="number"/><br/><br/><span>${dad28342eb2f408035e944bbb7d3c1bf4f065923:
		Brightness factor: }</span><input class="m" max="255" min="1" name="BF" required="" type="number"/> %
		<h3>${ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c:Transitions}</h3><span>${7b11999892c5b58c976c6cdb90b95c96653f8964:
		Enable transitions: }</span><input name="TF" onchange="gId('tran').style.display=this.checked?'inline':'none';" type="checkbox"/><br/>
<span id="tran"><span>${feda12b88eb10e058a8b3f27ec36a53d34a7594f:
			Effect blending: }</span><input name="EB" type="checkbox"/><br/><span>${df5238eebc59c4304cc7822de5d0ae9cd3909f3b:
			Default transition time: }</span><input class="xl" max="65500" min="0" name="TD" type="number"/><span>${c980fc9bd8fa926dcc04be62e2546551fac0c216: ms}</span><br/><span>${7265463da5a3d2ba6bb6df6ad4924f8e7cb863ca:
			Palette transitions: }</span><input name="PF" type="checkbox"/><br/>
</span>
<i>${c04a64d166eb683b928c418c18fbd6a6662eb2cd:Random Cycle}</i><span>${57823de649323799d434b69620ed7add27725c63: Palette Time: }</span><input class="m" max="255" min="1" name="TP" type="number"/><span>${06d1d860e2947128b9b52a760634ecefa34eb1a1: s}</span><br/><span>${0a5e38ba06ab44fd566cc9e753662bb441dc2609:
		Use harmonic }</span><i>${c04a64d166eb683b928c418c18fbd6a6662eb2cd:Random Cycle}</i><span>${863509fd1d1e5b17f97142b0d4f3ad5832906c3b: Palette: }</span><input name="TH" type="checkbox"/><br/>
<h3>${604a6a3a16d26e25ebf7863624044952ab3e8fd1:Timed light}</h3><span>${f0ba3fb6eadc91f747c055f5fc83411b35b33273:
		Default duration: }</span><input class="m" max="255" min="1" name="TL" required="" type="number"/><span>${f4e8a8b4ab16a38c118b5db1c5bb264282f1e9d8: min}</span><br/><span>${96213d353f760474c72649ea380126e63c782177:
		Default target brightness: }</span><input class="m" max="255" min="0" name="TB" required="" type="number"/><br/><span>${89d90f197972c8f01325fcce665a669593acb4ba:
		Mode:
		}</span><select name="TW">
<option value="0">${0a0245962f79b572eec92a646ae4421ce4ef513d:Wait and set}</option>
<option value="1">${5298d08bb7ae7d01f4efcdbb94ff03fc487fd11c:Fade}</option>
<option value="2">${c7d80197e1f40256bbd37dbcaa34c4200f21c7df:Fade Color}</option>
<option value="3">${fadf71c7ea92e6416fd6d89969f8e78a115cd3c1:Sunrise}</option>
</select>
<h3>${2b3b9b88fe9e209aafadd6a99cad3c4f30796e30:White management}</h3><span>${ec478c2e288140c68797b0ee679afbc6b2bf0e56:
		White Balance correction: }</span><input name="CCT" type="checkbox"/><br/>
<div id="wc"><span>${1021c15baff63949035b67f7fdc9222ec837d258:
			Global override for Auto-calculate white:}</span><br/>
<select name="AW">
<option value="255">${f4f4473df8cb59f0a369aebee3d1509adc0151c6:Disabled}</option>
<option value="0">${6eef6648406c333a4035cd5e60d0bf2ecf2606d7:None}</option>
<option value="1">${573fc704c06b13f4ecd91a92e340c723d32964b9:Brighter}</option>
<option value="2">${5f0869a88eb923f4b7f11e7b7b552413465e5768:Accurate}</option>
<option value="3">${89e4fa7c6e21bf128815cf184349592868a477ce:Dual}</option>
<option value="4">${a95e85aed56318093b024674e217cae0bd30241d:Max}</option>
</select>
<br/><span>${dd6a3b05b2424621afce1773d052aa56ba6eae52:
			Calculate CCT from RGB: }</span><input name="CR" type="checkbox"/><br/><span>${6de2323a871e2efdf647dfb1f0354f68bf091631:
			CCT IC used (Athom 15W): }</span><input name="IC" type="checkbox"/><br/><span>${bd8ecce562bf25a31105b610de59b1599c0f7f87:
			CCT additive blending: }</span><input class="s" max="100" min="0" name="CB" onchange="UI()" required="" type="number"/> %<br/>
<i class="warn"><span>${66559e8368c82c9d1cbf7fe87e619bd300241423:WARNING: When using H-bridge for reverse polarity (2-wire) CCT LED strip}</span><br/><b>${ae1160832e0f749c059bd3062c4d6274f3152541:make sure this value is 0}</b>.<br/><span>${2328083368a5dcafb193e9fce6a78a2d74b05fba:(ESP32 variants only, ESP8266 does not support H-bridges)}</span></i>
</div>
<h3>${4d064726954a17487f94e931f5b157b733ec22ed:Advanced}</h3><span>${5bb4fb5db7de3e21b5139509fe4fe153fc8a93e7:
		Palette wrapping:
		}</span><select name="PB">
<option value="0">${13beb7837f276f3ca23a245b2d56249271d1a0bf:Linear (wrap if moving)}</option>
<option value="1">${f5865d1a582e8fba1dcb2e9502577bb54fe02eaf:Linear (always wrap)}</option>
<option value="2">${e37f0d5010fd240f66e38faacba9b6c27ec49f36:Linear (never wrap)}</option>
<option value="3">${7c1cb97223e37e4a0ec08bb65da946267d72577f:None (not recommended)}</option>
</select><br/><span>${1961f92f491701475f54f08b4d789c55d0fe919c:
		Target refresh rate: }</span><input class="s" max="120" min="1" name="FR" required="" type="number"/><span>${e9c5818c534757ad91d0c0345c5efc209908b75e: FPS
		}</span><hr class="sml"/>
<div id="cfg"><span>${e7a9ba08e965324513a12fcc6249222c84d3f210:Config template: }</span><input accept=".json" name="data2" type="file"/><button class="sml" onclick="loadCfg(d.Sf.data2)" type="button">${cfea419c3b4e8b02ee586e70a28bf846e44cdda4:Apply}</button><br/></div>
<hr/>
<button onclick="B()" type="button">${b52b36b7269fbfc58ec24bb724691951a3decbe8:Back}</button><button type="submit">${efc007a393f66cdb14d57d385822a3d9e36ef873:Save}</button>
</form>
<div id="toast"></div>
<div id="I18N:template" style="display:none">wled00/data/settings_leds.htm</div></body>
</html>
